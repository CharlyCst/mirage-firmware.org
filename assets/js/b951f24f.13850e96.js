"use strict";(self.webpackChunkwebsite_miralis=self.webpackChunkwebsite_miralis||[]).push([[920],{7081:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var n=r(4848),t=r(8453);const s={},a="Architecture",o={id:"Developer/architecture",title:"Architecture",description:"Overview",source:"@site/docs/Developer/architecture.md",sourceDirName:"Developer",slug:"/Developer/architecture",permalink:"/docs/Developer/architecture",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"FAQ",permalink:"/docs/faq"},next:{title:"Contributing",permalink:"/docs/Developer/contributing"}},l={},d=[{value:"Overview",id:"overview",level:2},{value:"PMP Virtualization",id:"pmp-virtualization",level:2},{value:"Interrupts",id:"interrupts",level:2},{value:"RISCV interrupt system",id:"riscv-interrupt-system",level:3},{value:"Miralis interrupt virtualization",id:"miralis-interrupt-virtualization",level:3},{value:"Firmware",id:"firmware",level:4},{value:"Payload",id:"payload",level:4},{value:"Miralis",id:"miralis",level:4}];function c(e){const i={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h1,{id:"architecture",children:"Architecture"}),"\n",(0,n.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(i.p,{children:"The purpose of Miralis is to virtualize firmware.\nIn a standard RISC-V deployment, the firmware runs in M-mode, below the OS:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nU-mode  \u2502   User App   \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nS-mode  \u2502      OS      \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nM-mode  \u2502   Firmware   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,n.jsx)(i.p,{children:"Because M-mode is all-powerful, it has absolute control over the OS, including reading and modifying its data.\nThe traditional purpose of the firmware is the manage the SoC, that is initializing and configuring all devices, manage power, monitor temperature and device health, etc...\nIn addition, the firmware is increasingly used for security-critical features, such as enforcing isolation.\nFor instance, on Arm the firmware (EL3 on that architecture) is responsible for enforcing the security guarantees of confidential VMs (see Arm CCA extension)."}),"\n",(0,n.jsx)(i.p,{children:"We end-up in a situation where the firmware has two roles: to manage the physical board, and to enforce security policies.\nUnfortunately those two roles are in tension: hardware manufacturers tend to ship opaque firmware blob to manage proprietary hardware, while security require measured and open-source software to allow scrutiny."}),"\n",(0,n.jsx)(i.p,{children:"The purpose of Miralis is decouple those two functions: on one hand it can support opaque firmware for managing the board, and on the other it can enforce security by isolating the OS.\nThe way Miralis achieve this is through firmware virtualization.\nAt a high level, a deployment on top of Miralis looks like this:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nU-mode  \u2502   User App   \u2502 \u2502  Firmware  \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nS-mode  \u2502      OS      \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nM-mode  \u2502           Miralis           \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,n.jsx)(i.p,{children:"Miralis itself runs in M-mode in the place where one would usually find the firmware.\nBut because the hardware still requires a firmware to function properly, Miralis actually runs the firmware in U-mode and virtualizes all privileged operations, such as interacting with M-mode registers.\nAt the same time, Miralis allows running a standard OS like it usually would, in S-mode.\nThe OS can call into the firmware, and miralis will take care of forwarding those calls appropriately.\nThat way, Miralis manages to keep all the firmware functionalities, but can enforce strong security guarantees, such as ensuring that the firmware can never access the  OS memory."}),"\n",(0,n.jsx)(i.h2,{id:"pmp-virtualization",children:"PMP Virtualization"}),"\n",(0,n.jsx)(i.p,{children:"One of the main aspect of OS virtualization is MMU (Memory Management Unit) virtualization.\nThe MMU can be virtualized using either pure software shadow page tables, or using hardware assisted 2-level page tables."}),"\n",(0,n.jsx)(i.p,{children:"In the case of Miralis we have no such concerns, because M-mode doesn't have access to an MMU (S-mode does, but Miralis doesn't need to virtualize it).\nInstead, M-mode has access to PMP (Physical Memory Protection) registers, which falls under the category of MPU (Memory Protection Unit) often found in embedded micro-controllers.\nMiralis needs to protect its own memory using PMP while still exposing PMP to the firmware to protect itself from the OS.\nFor that purpose Miralis needs to virtualize and multiplex the physical PMP registers."}),"\n",(0,n.jsx)(i.p,{children:"PMP registers form an ordered list of physical memory ranges with attached access rights.\nThe first entry that matches a given address determines the access rights for that particular load or store.\nFor more details regarding PMP, please refer to the RISC-V privileged specification."}),"\n",(0,n.jsx)(i.p,{children:"Miralis split PMP registers in four groups, as depicted bellow with the example of 8 physical PMP registers:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2500\u2510\n\u2502  PMP 0  \u2502  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502 For Miralis use\n\u2502  PMP 1  \u2502  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2500\u2524\n\u2502    0    \u2502  \u2502 Null entry\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2500\u2524\n\u2502 vPMP 0  \u2502  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502 vPMP 1  \u2502  \u2502 Virtual PMP registers,\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502 dedicated for firmware\n\u2502 vPMP 2  \u2502  \u2502 use\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502 vPMP 3  \u2502  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2500\u2524\n\u2502   All   \u2502  \u2502 Default allow/deny all\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2500\u2518\n"})}),"\n",(0,n.jsx)(i.p,{children:"The first few registers are reserved for Miralis's own use.\nThey are placed first to take priority over firmware-controlled PMP registers.\nThen Miralis inserts a null entry with address 0, this is required to ensure that the first virtual PMP behaves like the first physical PMP when using TOR (Top Of Range) addressing (refer to the spec for details).\nThen the next PMP registers are exposed to the firmware as virtual PMP registers.\nFrom the firmware point of view, it looks like if there were only PMP 0 to 3 in the example above.\nFinally, the last entry is used by Miralis to either allow access to all memory when running the firmware (to emulate full memory access in virtual M-mode), or disallow all access when running in S or U-mode."}),"\n",(0,n.jsx)(i.h2,{id:"interrupts",children:"Interrupts"}),"\n",(0,n.jsx)(i.h3,{id:"riscv-interrupt-system",children:"RISCV interrupt system"}),"\n",(0,n.jsx)(i.p,{children:"When the firmware is running, we want to receive all interrupts the firmware wants to receive. Theses enabled interrupts can be known by having a look at some virtuals context registers:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"mie"})," register informs us on the individually enabled interrupts. ",(0,n.jsx)(i.code,{children:"mip"})," register holds the pending interrupts by setting the corresponding bit when an interrupt occurs. A pending interrupt can trap only if the corresponding bit in ",(0,n.jsx)(i.code,{children:"mie"})," and in ",(0,n.jsx)(i.code,{children:"mip"})," is set. Here is the layout of both registers. Please refer to the ",(0,n.jsx)(i.a,{href:"https://drive.google.com/file/d/17GeetSnT5wW3xNuAHI95-SI1gPGd5sJ_/view?usp=drive_link",children:"specification"})," for the detailed explanation of each field."]}),"\n"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"      15 14  13  12  11 10   9  8   7  6   5  4   3  2   1  0\n      \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2510          \nmie : \u25020 0\u2502LCOFIE\u25020\u2502MEIE\u25020\u2502SEIE\u25020\u2502MTIE|0|STIE|0|MSIE|0|SSIE|0|       \n      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2518   \n\n      15 14  13  12  11 10   9  8   7  6   5  4   3  2   1  0\n      \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2510          \nmip : \u25020 0\u2502LCOFIP\u25020\u2502MEIP\u25020\u2502SEIP\u25020\u2502MTIP|0|STIP|0|MSIP|0|SSIP|0|       \n      \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2518         \n"})}),"\n",(0,n.jsxs)(i.ol,{start:"2",children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"mideleg"})," register allows delegating interrupts to less-privileged mode. The layout of ",(0,n.jsx)(i.code,{children:"mideleg"})," matches the one of ",(0,n.jsx)(i.code,{children:"mie"})," and ",(0,n.jsx)(i.code,{children:"mip"}),". If an interrupt is pending and delegated, it will not trap, whatever the value in ",(0,n.jsx)(i.code,{children:"mie"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:["The MIE bit in the ",(0,n.jsx)(i.code,{children:"mstatus"})," register control if interrupts are globally enabled for machine mode. If ",(0,n.jsx)(i.code,{children:"mstatus.MIE"})," is disabled and an interrupt is pending, it will not trap, whatever the values in ",(0,n.jsx)(i.code,{children:"mie"})," and ",(0,n.jsx)(i.code,{children:"mideleg"}),". If the running mode is less than M, global interrupts for M-mode are always enabled."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"To sum up, in riscv, in order to trap to M-Mode, we need:"}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(RISCV-SPEC)"}),(0,n.jsx)(i.br,{}),"\n","Executing mode = ",(0,n.jsx)(i.strong,{children:"M"}),":",(0,n.jsx)(i.br,{}),"\n",(0,n.jsx)(i.code,{children:"trap \u27fa mip[i] \u2227 mie[i] \u2227 mstatus.MIE \u2227 \xacmideleg[i]"})]}),"\n",(0,n.jsxs)(i.p,{children:["Executing mode = ",(0,n.jsx)(i.strong,{children:"S"}),":",(0,n.jsx)(i.br,{}),"\n",(0,n.jsx)(i.code,{children:"trap \u27fa mip[i] \u2227 mie[i] \u2227 \xacmideleg[i]"})]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"miralis-interrupt-virtualization",children:"Miralis interrupt virtualization"}),"\n",(0,n.jsx)(i.p,{children:"In order to properly virtualize interrupts and correctly handle them, we need to follow many rules. The goal is to ensure that all interrupts destined to the firmware are correctly virtualized, so that the firmware get exactly its destined interrupts."}),"\n",(0,n.jsxs)(i.p,{children:["We virtualize registers inside the virtual context of the firmware. Registers ",(0,n.jsx)(i.code,{children:"mie"}),", ",(0,n.jsx)(i.code,{children:"mip"}),", ",(0,n.jsx)(i.code,{children:"mideleg"}),", ",(0,n.jsx)(i.code,{children:"mstatus"})," will have their virtual counterparts ",(0,n.jsx)(i.code,{children:"vmie"}),", ",(0,n.jsx)(i.code,{children:"vmie"}),", ",(0,n.jsx)(i.code,{children:"vmideleg"})," and ",(0,n.jsx)(i.code,{children:"vmstatus"}),". In this section, we will also say that the firmware is running in ",(0,n.jsx)(i.strong,{children:"vM-mode"})," (M-mode virtualized by Miralis inside U-mode). Let's now separate the cases into the three execution states that could occur:"]}),"\n",(0,n.jsx)(i.h4,{id:"firmware",children:"Firmware"}),"\n",(0,n.jsxs)(i.p,{children:["When the firmware is running, we want Miralis to receive ",(0,n.jsx)(i.strong,{children:"all"})," interrupts the firmware expects to receive: no interrupt is delegated to firmware. We then set ",(0,n.jsx)(i.code,{children:"mideleg"})," to 0 when executing the firmware. We also want to receive ",(0,n.jsx)(i.strong,{children:"only"})," interrupts the firmware expects to receive. We then must filter ",(0,n.jsx)(i.code,{children:"mie"})," register to not trap on delegated interrupts or disabled interrupts. If an interrupt occurs, we need to reflect ",(0,n.jsx)(i.code,{children:"mip"})," into ",(0,n.jsx)(i.code,{children:"vmip"})," to let the firmware know which one."]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(MIDELEG-VM-MODE)"}),(0,n.jsx)(i.br,{}),"\n","mideleg \u2261 0, if mode = vM"]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(MIE-VM-MODE)"}),(0,n.jsx)(i.br,{}),"\n","mie = \xacvmideleg \u2227 vmstatus.MIE \u2227 vmie, if mode = vM"]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(MIP-VM-MODE)"}),"\nvmip = mip, if mode = vM"]}),"\n"]}),"\n",(0,n.jsx)(i.h4,{id:"payload",children:"Payload"}),"\n",(0,n.jsxs)(i.p,{children:["When switching to S-mode, we want to install ",(0,n.jsx)(i.code,{children:"vmideleg"})," into ",(0,n.jsx)(i.code,{children:"mideleg"})," and ",(0,n.jsx)(i.code,{children:"vmie"})," to ",(0,n.jsx)(i.code,{children:"mie"}),", because the states of ",(0,n.jsx)(i.code,{children:"mideleg"})," and ",(0,n.jsx)(i.code,{children:"mie"})," may influence S-mode interrupts handling."]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(MIDELEG-S-MODE)"}),(0,n.jsx)(i.br,{}),"\n","mideleg \u2261 vmideleg, if mode = S"]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(MIE-S-MODE)"}),(0,n.jsx)(i.br,{}),"\n","mie \u2261 vmie, if mode = S"]}),"\n"]}),"\n",(0,n.jsx)(i.h4,{id:"miralis",children:"Miralis"}),"\n",(0,n.jsxs)(i.p,{children:["When Miralis is running, we don't want to receive interrupts: we want to handle them one by one. A simple way to ensure that is to make sure that ",(0,n.jsx)(i.code,{children:"mstatus.MIE"})," is always 0. As interrupts are globally enabled for M-mode when a less-privileged mode is running, Miralis will still get the interrupts of S-mode (e.g. payload) and U-mode (e.g. firmware)."]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(MSTATUS-MIE)"}),(0,n.jsx)(i.br,{}),"\n","mstatus.MIE \u2261 0"]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Now we show that if Miralis get an interrupt from firmware or the payload, it's correctly forwarded to the firmware interrupt handler and the virtual context is properly set to a trap state for the firmware."}),"\n",(0,n.jsxs)(i.p,{children:["When running in ",(0,n.jsx)(i.strong,{children:"vM-mode"}),", we have the following properties:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \n         \u250c\u2500\u2500>\u2502 Firmware \u2502\u2500\u2500\u2500\u2510       (1) An interrupt occurs when the firmware is     \n         \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   |           running. Switch to Miralis. \n      (2)\u2502                  |(1)    (2) Miralis virtualizes interrupt and       \n         \u2502                  |           transmit handling to firmware's interrupt     \n         \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   |           handler.   \n         \u2514\u2500\u2500\u2500\u2502 Miralis  \u2502<\u2500\u2500\u2518                  \n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \n                   \nMiralis receives interrupt i when executing firmware: \n  (RISCV-SPEC)\n  \u27f9 mstatus.MIE = -, mie[i] = 1, mip[i] = 1, mideleg[i] = 0 \n\n  (MIE-VM-MODE)\n  \u27f9 vmstatus.MIE = 1, vmie[i] = 1, vmideleg[i] = 0\n\t\n  (MIP-VM-MODE)\n  \u27f9 vmip[i] = mip [i] = 1\n  \n  Then, vmstatus.MIE = 1 \u2227 vmip[i] = 1 \u2227 vmie[i] = 1 \u2227 vmideleg[i] = 0  \n  (RISCV-SPEC)\n  \u27f9 virtual context is set as a tap occured in the firmware,\n     we can forward interrupt handling to firmware. \n"})}),"\n",(0,n.jsxs)(i.p,{children:["When running in ",(0,n.jsx)(i.strong,{children:"S-mode"}),", we have the following properties:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 (1) An interrupt occurs when the payload is      \n  \u2502 Payload \u2502<\u2500\u2500\u2510   \u250c\u2500\u2500>\u2502Firmware \u2502     running. Switch to Miralis. \n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502   \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (2) Miralis virtualizes interrupt and transmit     \n        \u2502    (4)\u2502   \u2502(2)    \u2502           handling to firmware's interrupt handler. \n     (1)\u2502       \u2502   \u2502       \u2502(3)    (3) Firmware's handler handle interrupt then        \n        \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502           mret to payload.      \n        \u2514\u2500\u2500\u2500>\u2502 Miralis \u2502<\u2500\u2500\u2500\u2518       (4) Miralis installs registers and emulate\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                mret to payload.                                       \n\nMiralis receives interrupt i when executing payload: \n  (RISCV-SPEC) \n  \u27f9 mstatus.MIE = -, mie[i] = 1, mip[i] = 1, mideleg[i] = 0  \n\n  (MIE-S-MODE, MIDELEG-S-MODE)\n  \u27f9 vmie[i] = 1, vmideleg[i] = 0 \n  \n  (MIP-VM-MODE)\n  \u27f9 vmip[i] = mip [i] = 1\n  \n  Then, vmstatus.MIE = - \u2227 vmip[i] = 1 \u2227 vmie[i] = 1 \u2227 vmideleg[i] = 0  \n  (RISCV-SPEC)\n  \u27f9 virtual context is set as a tap occured to the firmware,\n     we can forward interrupt handling to firmware. \n"})})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,i,r)=>{r.d(i,{R:()=>a,x:()=>o});var n=r(6540);const t={},s=n.createContext(t);function a(e){const i=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);